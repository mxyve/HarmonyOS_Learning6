@Component
export struct ClassroomRewards {
  @State private particles: Array<Particle> = []
  private ctx: Canvas2DContext | null = null
  private timer: number = -1
  private canvasWidth: number = 400
  private canvasHeight: number = 300

  // æ ·å¼å±æ€§
  private stackWidth: string = '100%'
  private stackHeight: string = this.canvasHeight + 'px'

  private buttonPadding: number = 15
  private buttonFontSize: number = 18
  private buttonBgColor: string = '#45b7d1'
  private buttonBorderRadius: number = 10
  private buttonMargin: number = 20

  private canvasWidthStr: string = this.canvasWidth + 'px'
  private canvasHeightStr: string = this.canvasHeight + 'px'

  build(): void {
    Stack() {
      Button('ğŸ’¯ é«˜åˆ†æµ‹éªŒ')
        .onClick(() => this.fire())
        .padding(this.buttonPadding)
        .fontSize(this.buttonFontSize)
        .backgroundColor(this.buttonBgColor)
        .borderRadius(this.buttonBorderRadius)
        .margin(this.buttonMargin)

      Canvas()
        .width(this.canvasWidthStr)
        .height(this.canvasHeightStr)
        .onReady(this.handleCanvasReady.bind(this))
    }
    .width(this.stackWidth)
    .height(this.stackHeight)
  }

  private handleCanvasReady(): void {
    // åˆ›å»ºCanvaså…ƒç´ å®ç°ç±»å®ä¾‹ï¼Œä¸ä¼ é€’thiså¼•ç”¨
    const canvasElement: CanvasElement = new CanvasElementImpl();
    this.ctx = canvasElement.getContext('2d');
    this.startLoop();
  }

  // å°†æ–¹æ³•æ”¹ä¸ºå…¬å…±æ–¹æ³•ï¼Œå…è®¸å¤–éƒ¨è®¿é—®
  public createCanvas2DContext(): Canvas2DContext {
    return new Canvas2DContextImpl();
  }

  private fire(): void {
    this.particles = [];
    for (let i = 0; i < 60; i++) {
      const particle: Particle = this.createParticle();
      this.particles.push(particle);
    }
    setTimeout(() => this.particles = [], 2000);
  }

  private createParticle(): Particle {
    return {
      x: Math.random() * this.canvasWidth,
      y: -20,
      size: Math.random() * 5 + 3,
      color: this.randColor(),
      speed: Math.random() * 3 + 2
    };
  }

  private randColor(): string {
    const colors: string[] = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#feca57', '#ff9ff3'];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  private startLoop(): void {
    if (this.timer !== -1) {
      clearInterval(this.timer);
    }

    this.timer = setInterval(() => {
      if (!this.ctx) return;

      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

      for (let i = this.particles.length - 1; i >= 0; i--) {
        const p: Particle = this.particles[i];
        p.y += p.speed;

        if (p.y > this.canvasHeight) {
          this.particles.splice(i, 1);
          continue;
        }

        this.ctx.fillStyle = p.color;
        this.ctx.beginPath();
        this.ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
        this.ctx.fill();
      }
    }, 16);
  }

  aboutToDisappear(): void {
    if (this.timer !== -1) {
      clearInterval(this.timer);
    }
  }
}

// ä¿®æ”¹Canvaså…ƒç´ å®ç°ç±»ï¼Œç›´æ¥åˆ›å»ºä¸Šä¸‹æ–‡
class CanvasElementImpl implements CanvasElement {
  getContext(contextType: string): Canvas2DContext | null {
    if (contextType === '2d') {
      // ç›´æ¥åˆ›å»ºä¸Šä¸‹æ–‡å®ä¾‹ï¼Œä¸ä¾èµ–å¤–éƒ¨ç±»
      return new Canvas2DContextImpl();
    }
    return null;
  }
}

// Canvas2Dä¸Šä¸‹æ–‡å®ç°ç±»
class Canvas2DContextImpl implements Canvas2DContext {
  fillStyle: string = '';

  clearRect(x: number, y: number, width: number, height: number): void {
    // å®é™…å®ç°ç”±ArkUIæä¾›
  }

  beginPath(): void {
    // å®é™…å®ç°ç”±ArkUIæä¾›
  }

  arc(x: number, y: number, radius: number, startAngle: number, endAngle: number): void {
    // å®é™…å®ç°ç”±ArkUIæä¾›
  }

  fill(): void {
    // å®é™…å®ç°ç”±ArkUIæä¾›
  }
}

// ç²’å­æ¥å£
interface Particle {
  x: number;
  y: number;
  size: number;
  color: string;
  speed: number;
}

// Canvasç›¸å…³æ¥å£
interface CanvasElement {
  getContext(contextType: string): Canvas2DContext | null;
}

interface Canvas2DContext {
  fillStyle: string;
  clearRect(x: number, y: number, width: number, height: number): void;
  beginPath(): void;
  arc(x: number, y: number, radius: number, startAngle: number, endAngle: number): void;
  fill(): void;
}
